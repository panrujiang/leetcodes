# 算法

## 1.树的遍历

$$
树的遍历\begin{cases}
深度优先遍历（递归或栈模拟）\begin{cases}
先序遍历\\
中序遍历\\
后序遍历
\end{cases}\\
广度优先搜素\begin{cases}
层序遍历
\end{cases}\\
\end{cases}
$$

例子：

![image-20231218211430252](C:\Users\31445\AppData\Roaming\Typora\typora-user-images\image-20231218211430252.png)

深度优先遍历（递归法）：

```
class Solution {
public:
    int calculateDepth(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        return max(calculateDepth(root -> left),calculateDepth(root -> right)) + 1;
    }
};
```

广度优先遍历（队列模拟）：

```
class Solution {
public:
    int calculateDepth(TreeNode* root) {
        queue<TreeNode *> que;
        int depth = 0;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i ++){
                TreeNode * node = que.front();
                que.pop();
                if(node -> left) que.push(node -> left);
                if(node -> right) que.push(node -> right);
            }
            depth ++;
        }
        return depth;
    }
};
```

## 2.链表相关

### 1.找到链表的中间节点（双指针）

```
ListNode *slow = head, *fast = head -> next;
        while(fast && fast -> next){
            slow = slow -> next;
            fast = fast -> next -> next;
        }

```

### 2.反转链表

```
ListNode * reverseList(ListNode * head){
        ListNode * prev = NULL;
        ListNode * curr = head;
        while(curr){
            ListNode * next = curr -> next;
            curr -> next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
```

### 3.环形链表

首先判断链表是否有环：

![image-20240402113630062](C:\Users\31445\AppData\Roaming\Typora\typora-user-images\image-20240402113630062.png)

套路题：用快慢指针法：

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast -> next){
            slow = slow -> next;
            fast = fast -> next -> next;
            if(fast == slow){
                return true;
            }
        }
        return false;
    }
};
```

确定了有环，再找找环的入口：

![image-20240402114343349](C:\Users\31445\AppData\Roaming\Typora\typora-user-images\image-20240402114343349.png)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast -> next){
            slow = slow -> next;
            fast = fast -> next -> next;
            if(fast == slow){
                fast = head;
                while(fast != slow){
                    fast = fast -> next;
                    slow = slow -> next;
                }
                return slow;
            }
        }
       return NULL;
    }
};
```

引申一下：

![image-20240402115319348](C:\Users\31445\AppData\Roaming\Typora\typora-user-images\image-20240402115319348.png)

把索引和数组元素都看成一个节点，就形成了链表。

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);
        fast = 0;
        while(fast != slow){
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
};
```

### 4.快慢指针

![image-20240402115734776](C:\Users\31445\AppData\Roaming\Typora\typora-user-images\image-20240402115734776.png)

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummyNode = new ListNode(0);
        dummyNode -> next = head;
        ListNode* fast = dummyNode;
        ListNode* slow = dummyNode;
        int loop = n;
        while(loop --){
            fast = fast -> next;
        }
        while(fast -> next){
            fast = fast -> next;
            slow = slow -> next;
        }
        ListNode* tmp = slow -> next;
        slow -> next = slow -> next -> next;
        delete tmp;
        return dummyNode -> next;
    }
};
```

